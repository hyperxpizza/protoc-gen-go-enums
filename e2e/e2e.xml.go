
// Code generated by protoc-gen-go-xml-enums. DO NOT EDIT.
// source: e2e/e2e.proto
package e2e
import (
	"encoding/xml"
	"fmt"
	"github.com/iancoleman/strcase"
)


// UnmarshalXML implements xml.Unmarshaler
func (e *RootEnum) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v string
	err := d.DecodeElement(&v, &start)
	if err != nil {
		return err
	}

	// Exact match
	if val, ok := RootEnum_value[v]; ok {
		*e = RootEnum(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := RootEnum_value[v]; ok {
		*e = RootEnum(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("RootEnum"), v)
	if val, ok := RootEnum_value[v]; ok {
		*e = RootEnum(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum RootEnum", v)
}

// UnmarshalXMLAttr implements xml.Unmarshaler
func (e *RootEnum) UnmarshalXMLAttr(attr xml.Attr) error {
	v := attr.Value

	// Exact match
	if val, ok := RootEnum_value[v]; ok {
		*e = RootEnum(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := RootEnum_value[v]; ok {
		*e = RootEnum(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("RootEnum"), v)
	if val, ok := RootEnum_value[v]; ok {
		*e = RootEnum(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum RootEnum", v)
}

// MarshalXML implements xml.Marshaler
func (n RootEnum) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if val, ok := RootEnum_name[int32(n.Number())]; ok {
		return e.EncodeElement(val, start)
	}
	return fmt.Errorf("Invalid value \"%d\" for enum RootEnum", n)
}

// UnmarshalXML implements xml.Unmarshaler
func (e *ScreamingSnakeWithPrefix) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v string
	err := d.DecodeElement(&v, &start)
	if err != nil {
		return err
	}

	// Exact match
	if val, ok := ScreamingSnakeWithPrefix_value[v]; ok {
		*e = ScreamingSnakeWithPrefix(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := ScreamingSnakeWithPrefix_value[v]; ok {
		*e = ScreamingSnakeWithPrefix(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("ScreamingSnakeWithPrefix"), v)
	if val, ok := ScreamingSnakeWithPrefix_value[v]; ok {
		*e = ScreamingSnakeWithPrefix(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum ScreamingSnakeWithPrefix", v)
}

// UnmarshalXMLAttr implements xml.Unmarshaler
func (e *ScreamingSnakeWithPrefix) UnmarshalXMLAttr(attr xml.Attr) error {
	v := attr.Value

	// Exact match
	if val, ok := ScreamingSnakeWithPrefix_value[v]; ok {
		*e = ScreamingSnakeWithPrefix(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := ScreamingSnakeWithPrefix_value[v]; ok {
		*e = ScreamingSnakeWithPrefix(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("ScreamingSnakeWithPrefix"), v)
	if val, ok := ScreamingSnakeWithPrefix_value[v]; ok {
		*e = ScreamingSnakeWithPrefix(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum ScreamingSnakeWithPrefix", v)
}

// MarshalXML implements xml.Marshaler
func (n ScreamingSnakeWithPrefix) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if val, ok := ScreamingSnakeWithPrefix_name[int32(n.Number())]; ok {
		return e.EncodeElement(val, start)
	}
	return fmt.Errorf("Invalid value \"%d\" for enum ScreamingSnakeWithPrefix", n)
}

// UnmarshalXML implements xml.Unmarshaler
func (e *Nested_Enum) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v string
	err := d.DecodeElement(&v, &start)
	if err != nil {
		return err
	}

	// Exact match
	if val, ok := Nested_Enum_value[v]; ok {
		*e = Nested_Enum(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := Nested_Enum_value[v]; ok {
		*e = Nested_Enum(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("Nested_Enum"), v)
	if val, ok := Nested_Enum_value[v]; ok {
		*e = Nested_Enum(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum Nested_Enum", v)
}

// UnmarshalXMLAttr implements xml.Unmarshaler
func (e *Nested_Enum) UnmarshalXMLAttr(attr xml.Attr) error {
	v := attr.Value

	// Exact match
	if val, ok := Nested_Enum_value[v]; ok {
		*e = Nested_Enum(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := Nested_Enum_value[v]; ok {
		*e = Nested_Enum(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("Nested_Enum"), v)
	if val, ok := Nested_Enum_value[v]; ok {
		*e = Nested_Enum(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum Nested_Enum", v)
}

// MarshalXML implements xml.Marshaler
func (n Nested_Enum) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if val, ok := Nested_Enum_name[int32(n.Number())]; ok {
		return e.EncodeElement(val, start)
	}
	return fmt.Errorf("Invalid value \"%d\" for enum Nested_Enum", n)
}

// UnmarshalXML implements xml.Unmarshaler
func (e *Deeply_Nested_Enum) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v string
	err := d.DecodeElement(&v, &start)
	if err != nil {
		return err
	}

	// Exact match
	if val, ok := Deeply_Nested_Enum_value[v]; ok {
		*e = Deeply_Nested_Enum(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := Deeply_Nested_Enum_value[v]; ok {
		*e = Deeply_Nested_Enum(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("Deeply_Nested_Enum"), v)
	if val, ok := Deeply_Nested_Enum_value[v]; ok {
		*e = Deeply_Nested_Enum(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum Deeply_Nested_Enum", v)
}

// UnmarshalXMLAttr implements xml.Unmarshaler
func (e *Deeply_Nested_Enum) UnmarshalXMLAttr(attr xml.Attr) error {
	v := attr.Value

	// Exact match
	if val, ok := Deeply_Nested_Enum_value[v]; ok {
		*e = Deeply_Nested_Enum(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := Deeply_Nested_Enum_value[v]; ok {
		*e = Deeply_Nested_Enum(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("Deeply_Nested_Enum"), v)
	if val, ok := Deeply_Nested_Enum_value[v]; ok {
		*e = Deeply_Nested_Enum(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum Deeply_Nested_Enum", v)
}

// MarshalXML implements xml.Marshaler
func (n Deeply_Nested_Enum) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if val, ok := Deeply_Nested_Enum_name[int32(n.Number())]; ok {
		return e.EncodeElement(val, start)
	}
	return fmt.Errorf("Invalid value \"%d\" for enum Deeply_Nested_Enum", n)
}
