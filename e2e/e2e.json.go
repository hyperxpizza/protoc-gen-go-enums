
// Code generated by protoc-gen-go-enums. DO NOT EDIT.
// source: e2e/e2e.proto
package e2e
import (
	"encoding/json"
	"fmt"
	"github.com/iancoleman/strcase"
)


// UnmarshalXML implements xml.Unmarshaler
func (e *RootEnum) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}

	// Exact match
	if val, ok := RootEnum_value[v]; ok {
		*e = RootEnum(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := RootEnum_value[v]; ok {
		*e = RootEnum(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("RootEnum"), v)
	if val, ok := RootEnum_value[v]; ok {
		*e = RootEnum(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum RootEnum", v)
}

// MarshalXML implements xml.Marshaler
func (n RootEnum) MarshalJSON() ([]byte, error) {
	if val, ok := RootEnum_name[int32(n.Number())]; ok {
		return json.Marshal(val)
	}
	return []byte{}, fmt.Errorf("Invalid value \"%d\" for enum RootEnum", n)
}

// UnmarshalXML implements xml.Unmarshaler
func (e *ScreamingSnakeWithPrefix) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}

	// Exact match
	if val, ok := ScreamingSnakeWithPrefix_value[v]; ok {
		*e = ScreamingSnakeWithPrefix(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := ScreamingSnakeWithPrefix_value[v]; ok {
		*e = ScreamingSnakeWithPrefix(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("ScreamingSnakeWithPrefix"), v)
	if val, ok := ScreamingSnakeWithPrefix_value[v]; ok {
		*e = ScreamingSnakeWithPrefix(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum ScreamingSnakeWithPrefix", v)
}

// MarshalXML implements xml.Marshaler
func (n ScreamingSnakeWithPrefix) MarshalJSON() ([]byte, error) {
	if val, ok := ScreamingSnakeWithPrefix_name[int32(n.Number())]; ok {
		return json.Marshal(val)
	}
	return []byte{}, fmt.Errorf("Invalid value \"%d\" for enum ScreamingSnakeWithPrefix", n)
}

// UnmarshalXML implements xml.Unmarshaler
func (e *Nested_Enum) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}

	// Exact match
	if val, ok := Nested_Enum_value[v]; ok {
		*e = Nested_Enum(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := Nested_Enum_value[v]; ok {
		*e = Nested_Enum(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("Nested_Enum"), v)
	if val, ok := Nested_Enum_value[v]; ok {
		*e = Nested_Enum(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum Nested_Enum", v)
}

// MarshalXML implements xml.Marshaler
func (n Nested_Enum) MarshalJSON() ([]byte, error) {
	if val, ok := Nested_Enum_name[int32(n.Number())]; ok {
		return json.Marshal(val)
	}
	return []byte{}, fmt.Errorf("Invalid value \"%d\" for enum Nested_Enum", n)
}

// UnmarshalXML implements xml.Unmarshaler
func (e *Deeply_Nested_Enum) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}

	// Exact match
	if val, ok := Deeply_Nested_Enum_value[v]; ok {
		*e = Deeply_Nested_Enum(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := Deeply_Nested_Enum_value[v]; ok {
		*e = Deeply_Nested_Enum(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("Deeply_Nested_Enum"), v)
	if val, ok := Deeply_Nested_Enum_value[v]; ok {
		*e = Deeply_Nested_Enum(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum Deeply_Nested_Enum", v)
}

// MarshalXML implements xml.Marshaler
func (n Deeply_Nested_Enum) MarshalJSON() ([]byte, error) {
	if val, ok := Deeply_Nested_Enum_name[int32(n.Number())]; ok {
		return json.Marshal(val)
	}
	return []byte{}, fmt.Errorf("Invalid value \"%d\" for enum Deeply_Nested_Enum", n)
}
