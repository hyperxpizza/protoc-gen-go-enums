package main

import (
	"bytes"
	"fmt"
	"html/template"
	"strings"

	"google.golang.org/protobuf/types/descriptorpb"
)

type tplFile struct {
	*descriptorpb.FileDescriptorProto
}

type tplEnum struct {
	*descriptorpb.EnumDescriptorProto
}

func (h tplFile) GetPackageName() string {
	_, pkg, ok := parsePackageOption(h.FileDescriptorProto)

	if ok {
		pkg = strings.ReplaceAll(pkg, "-", "_")
		return pkg
	}

	pkg = h.GetPackage()
	pkg = strings.ReplaceAll(pkg, "-", "_")

	return pkg
}

func applyTemplateForMessageType(
	w *bytes.Buffer,
	f *descriptorpb.FileDescriptorProto,
	msg *descriptorpb.DescriptorProto,
	prefix string,
	fileTemplate *template.Template,
	enumTemplate *template.Template) (error, bool) {

	found := false

	for _, enum := range msg.GetEnumType() {
		tpl := tplEnum{
			enum,
		}

		prefixedName := fmt.Sprintf("%s_%s", prefix, *tpl.Name)
		tpl.Name = &prefixedName

		if err := enumTemplate.Execute(w, tpl); err != nil {
			return err, false
		}

		found = true
	}

	for _, nested := range msg.GetNestedType() {
		err, f := applyTemplateForMessageType(w, f, nested, fmt.Sprintf("%s_%s", prefix, nested.GetName()), fileTemplate, enumTemplate)

		if err != nil {
			return err, false
		}

		if f == true {
			found = true
		}
	}

	return nil, found
}

func applyTemplate(
	f *descriptorpb.FileDescriptorProto,
	fileTemplate *template.Template,
	enumTemplate *template.Template) (string, error, bool) {
	w := bytes.NewBuffer(nil)

	found := false

	if err := fileTemplate.Execute(w, tplFile{
		f,
	}); err != nil {
		return "", err, false
	}

	for _, enum := range f.GetEnumType() {
		if err := enumTemplate.Execute(w, tplEnum{
			enum,
		}); err != nil {
			return "", err, false
		}

		found = true
	}

	for _, msg := range f.GetMessageType() {
		err, f := applyTemplateForMessageType(w, f, msg, msg.GetName(), fileTemplate, enumTemplate)

		if err != nil {
			return "", err, false
		}

		if f == true {
			found = true
		}
	}

	return w.String(), nil, found
}

var (
	xmlFileTemplate = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-go-enums. DO NOT EDIT.
// source: {{.GetName}}
package {{.GetPackageName}}
import (
	"encoding/xml"
	"fmt"
	"github.com/iancoleman/strcase"
)

`))

	xmlEnumTemplate = template.Must(template.New("enum").Parse(`
// UnmarshalXML implements xml.Unmarshaler
func (e *{{.GetName}}) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v string
	err := d.DecodeElement(&v, &start)
	if err != nil {
		return err
	}

	// Exact match
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("{{.GetName}}"), v)
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum {{.GetName}}", v)
}

// UnmarshalXMLAttr implements xml.Unmarshaler
func (e *{{.GetName}}) UnmarshalXMLAttr(attr xml.Attr) error {
	v := attr.Value

	// Exact match
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("{{.GetName}}"), v)
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum {{.GetName}}", v)
}

// MarshalXML implements xml.Marshaler
func (n {{.GetName}}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if val, ok := {{.GetName}}_name[int32(n.Number())]; ok {
		return e.EncodeElement(val, start)
	}
	return fmt.Errorf("Invalid value \"%d\" for enum {{.GetName}}", n)
}
`))

	jsonFileTemplate = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-go-enums. DO NOT EDIT.
// source: {{.GetName}}
package {{.GetPackageName}}
import (
	"encoding/json"
	"fmt"
	"github.com/iancoleman/strcase"
)

`))

	jsonEnumTemplate = template.Must(template.New("enum").Parse(`
func (e *{{.GetName}}) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}

	// Exact match
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("{{.GetName}}"), v)
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum {{.GetName}}", v)
}

func (n {{.GetName}}) MarshalJSON() ([]byte, error) {
	if val, ok := {{.GetName}}_name[int32(n.Number())]; ok {
		return json.Marshal(val)
	}
	return []byte{}, fmt.Errorf("Invalid value \"%d\" for enum {{.GetName}}", n)
}
`))

	// ===== GraphQL templates =====

	gqlFileTemplate = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-go-enums. DO NOT EDIT.
// source: {{.GetName}}
package {{.GetPackageName}}
import (
	"fmt"
	"io"
	"strconv"
)

`))

	gqlEnumTemplate = template.Must(template.New("enum").Parse(`
// UnmarshalGQL implements graphql unmarshaling for {{.GetName}}
func (e *{{.GetName}}) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("{{.GetName}} must be a string, got %T", v)
	}

	// Exact match by enum name
	if val, ok := {{.GetName}}_value[s]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	return fmt.Errorf("invalid {{.GetName}} value %q", s)
}

// MarshalGQL implements graphql marshaling for {{.GetName}}
func (e {{.GetName}}) MarshalGQL(w io.Writer) {
	if name, ok := {{.GetName}}_name[int32(e.Number())]; ok {
		_, _ = io.WriteString(w, strconv.Quote(name))
		return
	}
	// Fallback to numeric value if unknown
	_, _ = io.WriteString(w, strconv.Quote(fmt.Sprintf("%d", int32(e))))
}
`))
)
