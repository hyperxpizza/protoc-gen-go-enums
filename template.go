package main

import (
	"bytes"
	"fmt"
	"html/template"

	"google.golang.org/protobuf/types/descriptorpb"
)

type tplFile struct {
	*descriptorpb.FileDescriptorProto
}

type tplEnum struct {
	*descriptorpb.EnumDescriptorProto
}

func (h tplFile) GetPackageName() string {
	_, pkg, ok := parsePackageOption(h.FileDescriptorProto)

	if ok {
		return pkg
	}

	return h.GetPackage()
}

func applyTemplateForMessageType(w *bytes.Buffer, f *descriptorpb.FileDescriptorProto, msg *descriptorpb.DescriptorProto, prefix string) (error, bool) {

	found := false

	for _, enum := range msg.GetEnumType() {
		tpl := tplEnum{
			enum,
		}

		prefixedName := fmt.Sprintf("%s_%s", prefix, *tpl.Name)
		tpl.Name = &prefixedName

		if err := enumTemplate.Execute(w, tpl); err != nil {
			return err, false
		}

		found = true
	}

	for _, nested := range msg.GetNestedType() {
		err, f := applyTemplateForMessageType(w, f, nested, fmt.Sprintf("%s_%s", prefix, nested.GetName()))

		if err != nil {
			return err, false
		}

		if f == true {
			found = true
		}
	}

	return nil, found
}

func applyTemplate(f *descriptorpb.FileDescriptorProto) (string, error, bool) {
	w := bytes.NewBuffer(nil)

	found := false

	if err := fileTemplate.Execute(w, tplFile{
		f,
	}); err != nil {
		return "", err, false
	}

	for _, enum := range f.GetEnumType() {
		if err := enumTemplate.Execute(w, tplEnum{
			enum,
		}); err != nil {
			return "", err, false
		}
	}

	for _, msg := range f.GetMessageType() {
		err, f := applyTemplateForMessageType(w, f, msg, msg.GetName())

		if err != nil {
			return "", err, false
		}

		if f == true {
			found = true
		}
	}

	return w.String(), nil, found
}

var (
	fileTemplate = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-go-xml-enums. DO NOT EDIT.
// source: {{.GetName}}
package {{.GetPackageName}}
import (
	"encoding/xml"
	"fmt"
	"github.com/iancoleman/strcase"
)

`))

	enumTemplate = template.Must(template.New("enum").Parse(`
// UnmarshalXML implements xml.Unmarshaler
func (e *{{.GetName}}) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var v string
	err := d.DecodeElement(&v, &start)
	if err != nil {
		return err
	}

	// Exact match
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("{{.GetName}}"), v)
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum {{.GetName}}", v)
}

// UnmarshalXMLAttr implements xml.Unmarshaler
func (e *{{.GetName}}) UnmarshalXMLAttr(attr xml.Attr) error {
	v := attr.Value

	// Exact match
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	// Screaming snake case match
	v = strcase.ToScreamingSnake(v)
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	// Screaming snake case match with enum name prefix
	v = fmt.Sprintf("%s_%s", strcase.ToScreamingSnake("{{.GetName}}"), v)
	if val, ok := {{.GetName}}_value[v]; ok {
		*e = {{.GetName}}(val)
		return nil
	}

	return fmt.Errorf("Invalid value \"%s\" for enum {{.GetName}}", v)
}

// MarshalXML implements xml.Marshaler
func (n {{.GetName}}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if val, ok := {{.GetName}}_name[int32(n.Number())]; ok {
		return e.EncodeElement(val, start)
	}
	return fmt.Errorf("Invalid value \"%d\" for enum {{.GetName}}", n)
}
`))
)
